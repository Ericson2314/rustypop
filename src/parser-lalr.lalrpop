// FIXME#1
//
// We currently accept `if return { /* expr */ } { /* then */ }` but
// it is unclear if we *should* do so (in fact, I would argue that we
// should not, because it is inconsistent with `if Struct { ... }`)
// and `if 3 .. {`. Options to resolve:
//
//    - disallow `if return/break/continue` altogether
//      - I lump in `break/continue` to allow for future compat where
//        they take an argument, but also because they are all
//        unconditionall diverging control-flow expressions
//    - permit `if return/break/continue` but not with a block argument
//      - consistent, but what's the point?
//    - kepe things as they are today
//
// I opted for #1 so far.

grammar;
pub crate: () = {
  shebang? inner_attr* mod_item* => (),
};
shebang: () = {
  SHEBANG_LINE => (),
};
inner_attr: () = {
  SHEBANG "[" meta_item "]" => (),
  INNER_DOC_COMMENT => (),
};
maybe_outer_attrs: () = {
  outer_attrs => (),
  () => (),
};
outer_attrs: () = {
  outer_attr => (),
  outer_attrs outer_attr => (),
};
outer_attr: () = {
  "#" "[" meta_item "]" => (),
  OUTER_DOC_COMMENT => (),
};
meta_item: () = {
  ident => (),
  ident "=" lit => (),
  ident "(" Comma<meta_item> ")" => (),
};
meta_seq: () = {
  () => (),
  meta_item => (),
  meta_seq "," meta_item => (),
};
attrs_and_vis: () = {
  maybe_outer_attrs visibility => (),
};
mod_item: () = {
  attrs_and_vis item => (),
};
item: () = {
  stmt_item => (),
  item_macro => (),
};
stmt_item: () = {
  item_static => (),
  item_const => (),
  item_type => (),
  block_item => (),
  view_item => (),
};
item_static: () = {
  "static" ident ":" ty "=" expr ";" => (),
  "static" "mut" ident ":" ty "=" expr ";" => (),
};
item_const: () = {
  "const" ident ":" ty "=" expr ";" => (),
};
item_macro: () = {
  PathExpr "!" ident? parens_delimited_token_trees ";" => (),
  PathExpr "!" ident? braces_delimited_token_trees => (),
  PathExpr "!" ident? brackets_delimited_token_trees ";" => (),
};
view_item: () = {
  use_item => (),
  extern_fn_item => (),
  "extern" "crate" ident ";" => (),
  "extern" "crate" ident "as" ident ";" => (),
};
extern_fn_item: () = {
  "extern" abi? item_fn => (),
};
use_item: () = {
  "use" view_path ";" => (),
};
view_path: () = {
  path_no_types_allowed => (),
  path_no_types_allowed "::" "{" "}" => (),
  "::" "{" "}" => (),
  path_no_types_allowed "::" "{" idents_or_self "}" => (),
  "::" "{" idents_or_self "}" => (),
  path_no_types_allowed "::" "{" idents_or_self "," "}" => (),
  "::" "{" idents_or_self "," "}" => (),
  path_no_types_allowed "::" "*" => (),
  "{" "}" => (),
  "{" idents_or_self "}" => (),
  "{" idents_or_self "," "}" => (),
  path_no_types_allowed "as" ident => (),
};
block_item: () = {
  item_fn => (),
  item_unsafe_fn => (),
  item_mod => (),
  item_foreign_mod => (),
  item_struct => (),
  item_enum => (),
  item_trait => (),
  item_impl => (),
};
maybe_ty_ascription: () = {
  ":" ty_sum => (),
  () => (),
};
maybe_init_expr: () = {
  "=" expr => (),
  () => (),
};
item_struct: () = {
  "struct" ident generic_params maybe_where_clause struct_decl_args => (),
  "struct" ident generic_params struct_tuple_args maybe_where_clause ";" => (),
  "struct" ident generic_params maybe_where_clause ";" => (),
};
struct_decl_args: () = {
  "{" struct_decl_fields "}" => (),
  "{" struct_decl_fields "," "}" => (),
};
struct_tuple_args: () = {
  "(" struct_tuple_fields ")" => (),
  "(" struct_tuple_fields "," ")" => (),
};
struct_decl_fields: () = {
  struct_decl_field => (),
  struct_decl_fields "," struct_decl_field => (),
  () => (),
};
struct_decl_field: () = {
  attrs_and_vis ident ":" ty_sum => (),
};
struct_tuple_fields: () = {
  struct_tuple_field => (),
  struct_tuple_fields "," struct_tuple_field => (),
};
struct_tuple_field: () = {
  attrs_and_vis ty_sum => (),
};
item_enum: () = {
  "enum" ident generic_params maybe_where_clause "{" enum_defs "}" => (),
  "enum" ident generic_params maybe_where_clause "{" enum_defs "," "}" => (),
};
enum_defs: () = {
  enum_def => (),
  enum_defs "," enum_def => (),
  () => (),
};
enum_def: () = {
  attrs_and_vis ident enum_args => (),
};
enum_args: () = {
  "{" struct_decl_fields "}" => (),
  "{" struct_decl_fields "," "}" => (),
  "(" maybe_ty_sums ")" => (),
  "=" expr => (),
  () => (),
};
item_mod: () = {
  "mod" ident ";" => (),
  "mod" ident "{" inner_attr* mod_item* "}" => (),
};
item_foreign_mod: () = {
  "extern" abi? "{" inner_attr* foreign_item* "}" => (),
};
abi: () = {
  str => (),
};
foreign_item: () = {
  attrs_and_vis "static" item_foreign_static => (),
  attrs_and_vis item_foreign_fn => (),
  attrs_and_vis "unsafe" item_foreign_fn => (),
};
item_foreign_static: () = {
  maybe_mut ident ":" ty ";" => (),
};
item_foreign_fn: () = {
  "fn" ident generic_params fn_decl_allow_variadic maybe_where_clause ";" => (),
};
fn_decl_allow_variadic: () = {
  fn_params_allow_variadic ret_ty => (),
};
fn_params_allow_variadic: () = {
  "(" ")" => (),
  "(" params ")" => (),
  "(" params "," ")" => (),
  "(" params "," "..." ")" => (),
};
visibility: () = {
  "pub" => (),
  () => (),
};
idents_or_self: () = {
  ident_or_self => (),
  ident_or_self "as" ident => (),
  idents_or_self "," ident_or_self => (),
};
ident_or_self: () = {
  ident => (),
  "self" => (),
};
item_type: () = {
  "type" ident generic_params maybe_where_clause "=" ty_sum ";" => (),
};
for_sized: () = {
  "for" "?" ident => (),
  "for" ident "?" => (),
  () => (),
};
item_trait: () = {
  maybe_unsafe "trait" ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause "{" maybe_trait_items "}" => (),
};
maybe_trait_items: () = {
  trait_items => (),
  () => (),
};
trait_items: () = {
  trait_item => (),
  trait_items trait_item => (),
};
trait_item: () = {
  trait_const => (),
  trait_type => (),
  trait_method => (),
};
trait_const: () = {
  maybe_outer_attrs "const" ident maybe_ty_ascription maybe_const_default ";" => (),
};
maybe_const_default: () = {
  "=" expr => (),
  () => (),
};
trait_type: () = {
  maybe_outer_attrs "type" ty_param ";" => (),
};
maybe_unsafe: () = {
  "unsafe" => (),
  () => (),
};
trait_method: () = {
  type_method => (),
  method => (),
};
type_method: () = {
  attrs_and_vis maybe_unsafe "fn" ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ";" => (),
  attrs_and_vis maybe_unsafe "extern" abi? "fn" ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ";" => (),
};
method: () = {
  attrs_and_vis maybe_unsafe "fn" ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block => (),
  attrs_and_vis maybe_unsafe "extern" abi? "fn" ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block => (),
};
impl_method: () = {
  attrs_and_vis maybe_unsafe "fn" ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block => (),
  attrs_and_vis maybe_unsafe "extern" abi? "fn" ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block => (),
};
item_impl: () = {
  maybe_unsafe "impl" generic_params ty_prim_sum maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe "impl" generic_params "(" ty ")" maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe "impl" generic_params trait_ref "for" ty_sum maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe "impl" generic_params "!" trait_ref "for" ty_sum maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe "impl" generic_params trait_ref "for" ".." "{" "}" => (),
  maybe_unsafe "impl" generic_params "!" trait_ref "for" ".." "{" "}" => (),
};
maybe_impl_items: () = {
  impl_items => (),
  () => (),
};
impl_items: () = {
  impl_item => (),
  impl_item impl_items => (),
};
impl_item: () = {
  impl_method => (),
  attrs_and_vis item_macro => (),
  impl_const => (),
  impl_type => (),
};
impl_const: () = {
  attrs_and_vis item_const => (),
};
impl_type: () = {
  attrs_and_vis "type" ident generic_params "=" ty_sum ";" => (),
};
item_fn: () = {
  "fn" ident generic_params fn_decl maybe_where_clause inner_attrs_and_block => (),
};
item_unsafe_fn: () = {
  "unsafe" "fn" ident generic_params fn_decl maybe_where_clause inner_attrs_and_block => (),
  "unsafe" "extern" abi? "fn" ident generic_params fn_decl maybe_where_clause inner_attrs_and_block => (),
};
fn_decl: () = {
  fn_params ret_ty => (),
};
fn_decl_with_self: () = {
  fn_params_with_self ret_ty => (),
};
fn_decl_with_self_allow_anon_params: () = {
  fn_anon_params_with_self ret_ty => (),
};
fn_params: () = {
  "(" maybe_params ")" => (),
};
fn_anon_params: () = {
  "(" anon_param anon_params_allow_variadic_tail ")" => (),
  "(" ")" => (),
};
fn_params_with_self: () = {
  "(" maybe_mut "self" maybe_ty_ascription maybe_comma_params ")" => (),
  "(" "&" maybe_mut "self" maybe_ty_ascription maybe_comma_params ")" => (),
  "(" "&" lifetime maybe_mut "self" maybe_ty_ascription maybe_comma_params ")" => (),
  "(" maybe_params ")" => (),
};
fn_anon_params_with_self: () = {
  "(" maybe_mut "self" maybe_ty_ascription maybe_comma_anon_params ")" => (),
  "(" "&" maybe_mut "self" maybe_ty_ascription maybe_comma_anon_params ")" => (),
  "(" "&" lifetime maybe_mut "self" maybe_ty_ascription maybe_comma_anon_params ")" => (),
  "(" maybe_anon_params ")" => (),
};
maybe_params: () = {
  params => (),
  params "," => (),
  () => (),
};
params: () = {
  param => (),
  params "," param => (),
};
param: () = {
  Pat ":" ty_sum => (),
};
inferrable_param: () = {
  Pat maybe_ty_ascription => (),
};
maybe_unboxed_closure_kind: () = {
  () => (),
  ":" => (),
  "&" maybe_mut ":" => (),
};
maybe_comma_params: () = {
  "," => (),
  "," params => (),
  "," params "," => (),
  () => (),
};
maybe_comma_anon_params: () = {
  "," => (),
  "," anon_params => (),
  "," anon_params "," => (),
  () => (),
};
maybe_anon_params: () = {
  anon_params => (),
  anon_params "," => (),
  () => (),
};
anon_params: () = {
  anon_param => (),
  anon_params "," anon_param => (),
};
anon_param: () = {
  named_arg ":" ty => (),
  ty => (),
};
anon_params_allow_variadic_tail: () = {
  "," "..." => (),
  "," anon_param anon_params_allow_variadic_tail => (),
  () => (),
};
named_arg: () = {
  ident => (),
  UNDERSCORE => (),
  "&" ident => (),
  "&" UNDERSCORE => (),
  ANDAND ident => (),
  ANDAND UNDERSCORE => (),
  "mut" ident => (),
};
ret_ty: () = {
  "->" "!" => (),
  "->" ty => (),
  () => (),
};
generic_params: () = {
  "<" lifetimes ">" => (),
  "<" lifetimes "," ">" => (),
  "<" lifetimes SHR => (),
  "<" lifetimes "," SHR => (),
  "<" lifetimes "," ty_params ">" => (),
  "<" lifetimes "," ty_params "," ">" => (),
  "<" lifetimes "," ty_params SHR => (),
  "<" lifetimes "," ty_params "," SHR => (),
  "<" ty_params ">" => (),
  "<" ty_params "," ">" => (),
  "<" ty_params SHR => (),
  "<" ty_params "," SHR => (),
  () => (),
};
maybe_where_clause: () = {
  () => (),
  where_clause => (),
};
where_clause: () = {
  "where" where_predicates => (),
  "where" where_predicates "," => (),
};
where_predicates: () = {
  where_predicate => (),
  where_predicates "," where_predicate => (),
};
where_predicate: () = {
  for_lifetimes? lifetime ":" bounds => (),
  for_lifetimes ty ":" ty_param_bounds => (),
};
for_lifetimes: () = {
  "for" "<" lifetimes ">" => (),
};
ty_params: () = {
  ty_param => (),
  ty_params "," ty_param => (),
};
path_no_types_allowed: () = {
  ident => (),
  "::" ident => (),
  "self" => (),
  "::" "self" => (),
  path_no_types_allowed "::" ident => (),
};
path_generic_args_without_colons: () = {
  ident => (),
  ident generic_args => (),
  ident "(" maybe_ty_sums ")" ret_ty => (),
  path_generic_args_without_colons "::" ident => (),
  path_generic_args_without_colons "::" ident generic_args => (),
  path_generic_args_without_colons "::" ident "(" maybe_ty_sums ")" ret_ty => (),
};
generic_args: () = {
  "<" generic_values ">" => (),
  "<" generic_values SHR => (),
  "<" generic_values GE => (),
  "<" generic_values ">>=" => (),
  SHL ty_qualified_path_and_generic_values ">" => (),
  SHL ty_qualified_path_and_generic_values SHR => (),
  SHL ty_qualified_path_and_generic_values GE => (),
  SHL ty_qualified_path_and_generic_values ">>=" => (),
};
generic_values: () = {
  maybe_lifetimes maybe_ty_sums_and_or_bindings => (),
};
maybe_ty_sums_and_or_bindings: () = {
  ty_sums => (),
  ty_sums "," => (),
  ty_sums "," bindings => (),
  bindings => (),
  bindings "," => (),
  () => (),
};
maybe_bindings: () = {
  "," bindings => (),
  () => (),
};

#[inline]
Pat: () = PatWithBindingMode<BindingMode>;

PatWithBindingMode<BM>: () = {
    UNDERSCORE => (),
    "&" PatWithBindingMode<RefBindingMode> => (),
    "&" "mut" Pat => (),
    ANDAND Pat => (),
    "(" Comma<Pat> ")" => (),
    "[" PatVec "]" => (),
    lit_or_path => (),
    lit_or_path "..." lit_or_path => (),
    PathExpr "{" PatStruct "}" => (),
    PathExpr "(" ".." ")" => (),
    PathExpr "(" Comma<Pat> ")" => (),
    PathExpr "!" ident? delimited_token_trees => (),
    BM ident => (),
    ident "@" Pat => (),
    BM ident "@" Pat => (),
    "box" Pat => (),
    "<" ty_sum maybe_as_trait_ref ">" "::" ident => (),
    SHL ty_sum maybe_as_trait_ref ">" "::" ident maybe_as_trait_ref ">" "::" ident => (),
};
pats_or: () = {
  Pat => (),
  pats_or "|1" Pat => (),
};
BindingMode: () = {
    RefBindingMode,
    "mut" => (),
};
RefBindingMode: () = {
    "ref" => (),
    "ref" "mut" => (),
};
lit_or_path: () = {
  PathExpr => (),
  lit => (),
  "-" lit => (),
};
PatField: () = {
  ident => (),
  BindingMode ident => (),
  "box" ident => (),
  "box" BindingMode ident => (),
  ident ":" Pat => (),
  BindingMode ident ":" Pat => (),
};
PatFields: () = {
  PatField => (),
  PatFields "," PatField => (),
};
PatStruct: () = {
  PatFields => (),
  PatFields "," => (),
  PatFields "," ".." => (),
  ".." => (),
};
PatVec: () = {
  PatVec_elts => (),
  PatVec_elts "," => (),
  PatVec_elts ".." => (),
  PatVec_elts "," ".." => (),
  PatVec_elts ".." "," PatVec_elts => (),
  PatVec_elts ".." "," PatVec_elts "," => (),
  PatVec_elts "," ".." "," PatVec_elts => (),
  PatVec_elts "," ".." "," PatVec_elts "," => (),
  ".." "," PatVec_elts => (),
  ".." "," PatVec_elts "," => (),
  ".." => (),
  () => (),
};
PatVec_elts: () = {
  Pat => (),
  PatVec_elts "," Pat => (),
};
ty: () = {
  ty_prim => (),
  "<" ty_sum maybe_as_trait_ref ">" "::" ident => (),
  SHL ty_sum maybe_as_trait_ref ">" "::" ident maybe_as_trait_ref ">" "::" ident => (),
  "(" ty_sums ")" => (),
  "(" ty_sums "," ")" => (),
  "(" ")" => (),
};
ty_prim: () = {
  path_generic_args_without_colons => (),
  "::" path_generic_args_without_colons => (),
  "self" "::" path_generic_args_without_colons => (),
  "box" ty => (),
  "*" maybe_mut_or_const ty => (),
  "&" ty => (),
  "&" "mut" ty => (),
  ANDAND ty => (),
  ANDAND "mut" ty => (),
  "&" lifetime maybe_mut ty => (),
  ANDAND lifetime maybe_mut ty => (),
  "[" ty "]" => (),
  "[" ty "," ".." expr "]" => (),
  "[" ty ";" expr "]" => (),
  "typeof" "(" expr ")" => (),
  UNDERSCORE => (),
  ty_bare_fn => (),
  for_in_type => (),
};
ty_bare_fn: () = {
  "fn" ty_fn_decl => (),
  "unsafe" "fn" ty_fn_decl => (),
  "extern" abi? "fn" ty_fn_decl => (),
  "unsafe" "extern" abi? "fn" ty_fn_decl => (),
};
ty_fn_decl: () = {
  generic_params fn_anon_params ret_ty => (),
};
for_in_type: () = {
  "for" "<" maybe_lifetimes ">" for_in_type_suffix => (),
};
for_in_type_suffix: () = {
  ty_bare_fn => (),
  trait_ref => (),
};
maybe_mut: () = {
  "mut" => (),
  () => (),
};
maybe_mut_or_const: () = {
  "mut" => (),
  "const" => (),
  () => (),
};
ty_qualified_path_and_generic_values: () = {
  ty_qualified_path maybe_bindings => (),
  ty_qualified_path "," ty_sums maybe_bindings => (),
};
ty_qualified_path: () = {
  ty_sum "as" trait_ref ">" "::" ident => (),
  ty_sum "as" trait_ref ">" "::" ident "+" ty_param_bounds => (),
};
maybe_ty_sums: () = {
  ty_sums => (),
  ty_sums "," => (),
  () => (),
};
ty_sums: () = {
  ty_sum => (),
  ty_sums "," ty_sum => (),
};
ty_sum: () = {
  ty => (),
  ty "+" ty_param_bounds => (),
};
ty_prim_sum: () = {
  ty_prim => (),
  ty_prim "+" ty_param_bounds => (),
};
maybe_ty_param_bounds: () = {
  ":" ty_param_bounds => (),
  () => (),
};
ty_param_bounds: () = {
  boundseq => (),
  () => (),
};
boundseq: () = {
  polybound => (),
  boundseq "+" polybound => (),
};
polybound: () = {
  "for" "<" maybe_lifetimes ">" bound => (),
  bound => (),
  "?" bound => (),
};
bindings: () = {
  binding => (),
  bindings "," binding => (),
};
binding: () = {
  ident "=" ty => (),
};
ty_param: () = {
  ident maybe_ty_param_bounds maybe_ty_default => (),
  ident "?" ident maybe_ty_param_bounds maybe_ty_default => (),
};
maybe_bounds: () = {
  ":" bounds => (),
  () => (),
};
bounds: () = {
  bound => (),
  bounds "+" bound => (),
};
bound: () = {
  lifetime => (),
  trait_ref => (),
};
maybe_ltbounds: () = {
  ":" ltbounds => (),
  () => (),
};
ltbounds: () = {
  lifetime => (),
  ltbounds "+" lifetime => (),
};
maybe_ty_default: () = {
  "=" ty_sum => (),
  () => (),
};
maybe_lifetimes: () = {
  lifetimes => (),
  lifetimes "," => (),
  () => (),
};
lifetimes: () = {
  lifetime_and_bounds => (),
  lifetimes "," lifetime_and_bounds => (),
};
lifetime_and_bounds: () = {
  LIFETIME maybe_ltbounds => (),
  "'static" => (),
};
lifetime: () = {
  LIFETIME => (),
  "'static" => (),
};
trait_ref: () = {
  path_generic_args_without_colons => (),
  "::" path_generic_args_without_colons => (),
};
inner_attrs_and_block: () = {
  "{" inner_attr* maybe_stmts "}" => (),
};
block: () = {
  "{" maybe_stmts "}" => (),
};
maybe_stmts: () = {
  stmts => (),
  stmts ExprNoStmtLike => (),
  ExprNoStmtLike => (),
  () => (),
};
stmts: () = {
  stmt => (),
  stmts stmt => (),
};
stmt: () = {
  let => (),
  stmt_item => (),
  "pub" stmt_item => (),
  outer_attrs stmt_item => (),
  outer_attrs "pub" stmt_item => (),
  ExprStmtLike => (),
  block => (),
  ExprNoStmtLike ";" => (),
  ";" => (),
};
maybe_exprs: () = {
  exprs => (),
  exprs "," => (),
  () => (),
};
maybe_expr: () = {
  expr => (),
  () => (),
};
exprs: () = {
  expr => (),
  exprs "," expr => (),
};
PathExpr: () = {
  path_generic_args_with_colons => (),
  "::" path_generic_args_with_colons => (),
  "self" "::" path_generic_args_with_colons => (),
};
path_generic_args_with_colons: () = {
  ident => (),
  path_generic_args_with_colons "::" ident => (),
  path_generic_args_with_colons "::" generic_args => (),
};
MacroExpr: () = {
  PathExpr "!" ident? parens_delimited_token_trees => (),
  PathExpr "!" ident? brackets_delimited_token_trees => (),
};

// Old-style names:
expr: () = Expr<"">;
nonparen_expr: () = Expr<"">;

// New-style names:
Expression: () = Expr<"">;

ExprNoStruct: () = Expr<":no_struct:">;
ExprNoStmtLike: () = Expr<":no_block:,:no_stmtlike:">;

// "V" is the Expr "Variant" and it indicates the context
// in which the expression appears. It is used to tweak
// the set of permitted expressions. It is a kind of
// list of restrictions:
//
// - ":no_struct:" --> do not permit `Struct {`
// - ":no_block:" --> do not permit `{ .. }`
// - ":no_stmtlike:" --> do not permit `match { .. }` and friends
//
// These can be combined, so ":no_block:,:no_struct:" would mean no
// structs or blocks. To cut down on possible variations, we maintain
// the invariant that any such groupings be in alphabetical order.
//
// etc.
Expr<V>: () = {
    ExprOrOr<V> => (),
    "return" if V !~ ":no_struct:" => (), // FIXME#1
    "return" ExprOptionalRhs<V> if V !~ ":no_struct:" => (), // FIXME#1
    ".." => (),
    LambdaExpr<V> => (),
    "move" LambdaExpr<V> => (),
    ExprOrOr<V> "=" Expr<V> => (),
    ExprOrOr<V> "<-" Expr<V> => (),
    ExprOrOr<V> ".." => (),
    ExprOrOr<V> ".." ExprOptionalRhs<V> => (),
    ExprOrOr<V> "<<=" Expr<V> => (),
    ExprOrOr<V> ">>=" Expr<V> => (),
    ExprOrOr<V> "-=" Expr<V> => (),
    ExprOrOr<V> "&=" Expr<V> => (),
    ExprOrOr<V> "|=" Expr<V> => (),
    ExprOrOr<V> "+=" Expr<V> => (),
    ExprOrOr<V> "*=" Expr<V> => (),
    ExprOrOr<V> "/=" Expr<V> => (),
    ExprOrOr<V> "^=" Expr<V> => (),
    ExprOrOr<V> "%=" Expr<V> => (),
};

ExprOptionalRhs<V>: () = {
    Expr<":no_block:,:no_struct:"> if V == ":no_struct:",
    Expr<V> if V != ":no_struct:" ,
};

ExprOrOr<V>: () = {
    ExprAndAnd<V>,
    ExprOrOr<V> OROR ExprAndAnd<V> => (),
};

ExprAndAnd<V>: () = {
    ExprEq<V>,
    ExprAndAnd<V> ANDAND ExprEq<V> => (),
};

ExprEq<V>: () = {
    ExprOr<V>,
    ExprOr<V> EQEQ ExprOr<V> => (),
    ExprOr<V> NE ExprOr<V> => (),
    ExprOr<V> "<" ExprOr<V> => (),
    ExprOr<V> ">" ExprOr<V> => (),
    ExprOr<V> LE ExprOr<V> => (),
    ExprOr<V> GE ExprOr<V> => (),
};

ExprOr<V>: () = {
    ExprXor<V>,
    ExprOr<V> "|1" ExprXor<V> => (),
};

ExprXor<V>: () = {
    ExprAnd<V>,
    ExprXor<V> "^" ExprAnd<V> => (),
};

ExprAnd<V>: () = {
    ExprShift<V>,
    ExprAnd<V> "&" ExprShift<V> => (),
};

ExprShift<V>: () = {
    ExprPlusMinus<V>,
    ExprShift<V> SHL ExprPlusMinus<V> => (),
    ExprShift<V> SHR ExprPlusMinus<V> => (),
};

ExprPlusMinus<V>: () = {
    ExprMulDiv<V>,
    ExprPlusMinus<V> "+" ExprMulDiv<V> => (),
    ExprPlusMinus<V> "-" ExprMulDiv<V> => (),
};

ExprMulDiv<V>: () = {
    ExprAs<V>,
    ExprMulDiv<V> "*" ExprAs<V> => (),
    ExprMulDiv<V> "/" ExprAs<V> => (),
    ExprMulDiv<V> "%" ExprAs<V> => (),
};

ExprAs<V>: () = {
    ExprSuffix<V>,
    ExprSuffix<V> "as" ty => (),
};

ExprSuffix<V>: () = {
    ExprAtom<V>,
    ExprSuffix<V> "." path_generic_args_with_colons => (),
    ExprSuffix<V> "." LIT_INTEGER => (),
    ExprSuffix<V> "[" Expression "]" => (),
    ExprSuffix<V> "(" Comma<Expression> ")" => (),
};

ExprPrefix<V>: () = {
    "box" ExprPrefix<V> => (),
    "-" ExprPrefix<V> => (),
    "!" ExprPrefix<V> => (),
    "*" ExprPrefix<V> => (),
    "&" maybe_mut ExprPrefix<V> => (),
};

ExprAtom<V>: () = {
    lit => (),
    PathExpr => (),
    "self" => (),
    MacroExpr => (),
    PathExpr "{" struct_expr_fields "}" if V !~ ":no_struct:" => (),
    "(" Comma<Expression> ")" => (),
    "[" Comma<Expression> "]" => (),
    "[" Expression ";" Expression "]" => (),
    "continue" if V !~ ":no_struct:" => (), // FIXME#1
    "continue" ident if V !~ ":no_struct:" => (), // FIXME#1
    "break" if V !~ ":no_struct:" => (), // FIXME#1
    "break" ident if V !~ ":no_struct:" => (), // FIXME#1
    expr_qualified_path => (),
    ExprStmtLike if V !~ ":no_stmtlike:" => (),
    block if V !~ ":no_block:" => (),
    ANDAND maybe_mut Expr<V> => (),
};

expr_qualified_path: () = {
  "<" ty_sum maybe_as_trait_ref ">" "::" ident maybe_qpath_params => (),
  SHL ty_sum maybe_as_trait_ref ">" "::" ident maybe_as_trait_ref ">" "::" ident => (),
  SHL ty_sum maybe_as_trait_ref ">" "::" ident generic_args maybe_as_trait_ref ">" "::" ident => (),
  SHL ty_sum maybe_as_trait_ref ">" "::" ident maybe_as_trait_ref ">" "::" ident generic_args => (),
  SHL ty_sum maybe_as_trait_ref ">" "::" ident generic_args maybe_as_trait_ref ">" "::" ident generic_args => (),
};
maybe_qpath_params: () = {
  "::" generic_args => (),
  () => (),
};
maybe_as_trait_ref: () = {
  "as" trait_ref => (),
  () => (),
};
LambdaExpr<V>: () = {
    AnyPipe Comma<inferrable_param>? "|1" Expr<V> => (),
    AnyPipe Comma<inferrable_param>? "|1" "->" ty "{" Expr<V> "}" => (),
};
struct_expr_fields: () = {
  field_inits => (),
  field_inits "," => (),
  maybe_field_inits default_field_init => (),
};
maybe_field_inits: () = {
  field_inits => (),
  field_inits "," => (),
  () => (),
};
field_inits: () = {
  field_init => (),
  field_inits "," field_init => (),
};
field_init: () = {
  ident ":" expr => (),
};
default_field_init: () = {
  ".." expr => (),
};
ExprStmtLike: () = {
  expr_match => (),
  expr_if => (),
  expr_if_let => (),
  expr_while => (),
  expr_while_let => (),
  expr_loop => (),
  expr_for => (),
  "unsafe" block => (),
  PathExpr "!" ident? braces_delimited_token_trees => (),
};
ExprStmtLikeSuffix: () = {
  ExprStmtLike => (),
  ExprStmtLikeSuffix "." path_generic_args_with_colons => (),
  ExprStmtLikeSuffix "." path_generic_args_with_colons "[" maybe_expr "]" => (),
  ExprStmtLikeSuffix "." path_generic_args_with_colons "(" maybe_exprs ")" => (),
  ExprStmtLikeSuffix "." LIT_INTEGER => (),
};
expr_match: () = {
  "match" ExprNoStruct "{" "}" => (),
  "match" ExprNoStruct "{" match_clauses "}" => (),
  "match" ExprNoStruct "{" match_clauses nonblock_match_clause "}" => (),
  "match" ExprNoStruct "{" nonblock_match_clause "}" => (),
};
match_clauses: () = {
  match_clause => (),
  match_clauses match_clause => (),
};
match_clause: () = {
  nonblock_match_clause "," => (),
  block_match_clause => (),
  block_match_clause "," => (),
};
nonblock_match_clause: () = {
  maybe_outer_attrs pats_or maybe_guard "=>" ExprNoStmtLike => (),
  maybe_outer_attrs pats_or maybe_guard "=>" ExprStmtLikeSuffix => (),
};
block_match_clause: () = {
  maybe_outer_attrs pats_or maybe_guard "=>" block => (),
};
maybe_guard: () = {
  "if" ExprNoStruct => (),
  () => (),
};
expr_if: () = {
  "if" ExprNoStruct block => (),
  "if" ExprNoStruct block "else" block_or_if => (),
};
expr_if_let: () = {
  "if" "let" Pat "=" ExprNoStruct block => (),
  "if" "let" Pat "=" ExprNoStruct block "else" block_or_if => (),
};
block_or_if: () = {
  block => (),
  expr_if => (),
  expr_if_let => (),
};
expr_while: () = {
  maybe_label "while" ExprNoStruct block => (),
};
expr_while_let: () = {
  maybe_label "while" "let" Pat "=" ExprNoStruct block => (),
};
expr_loop: () = {
  maybe_label "loop" block => (),
};
expr_for: () = {
  maybe_label "for" Pat "in" ExprNoStruct block => (),
};
maybe_label: () = {
  lifetime ":" => (),
  () => (),
};
let: () = {
  "let" Pat maybe_ty_ascription maybe_init_expr ";" => (),
};
lit: () = {
  LIT_BYTE => (),
  LIT_CHAR => (),
  LIT_INTEGER => (),
  LIT_FLOAT => (),
  "true" => (),
  "false" => (),
  str => (),
};
str: () = {
  LIT_STR => (),
  LIT_STR_RAW => (),
  LIT_BYTE_STR => (),
  LIT_BYTE_STR_RAW => (),
};
ident: () = {
  IDENT => (),
};
unpaired_token: () = {
  SHL => (),
  SHR => (),
  LE => (),
  EQEQ => (),
  NE => (),
  GE => (),
  ANDAND => (),
  "<-" => (),
  "<<=" => (),
  ">>=" => (),
  "-=" => (),
  "&=" => (),
  "|=" => (),
  "+=" => (),
  "*=" => (),
  "/=" => (),
  "^=" => (),
  "%=" => (),
  ".." => (),
  "..." => (),
  "::" => (),
  "->" => (),
  LIT_BYTE => (),
  LIT_CHAR => (),
  LIT_INTEGER => (),
  LIT_FLOAT => (),
  LIT_STR => (),
  LIT_STR_RAW => (),
  LIT_BYTE_STR => (),
  LIT_BYTE_STR_RAW => (),
  IDENT => (),
  UNDERSCORE => (),
  LIFETIME => (),
  "self" => (),
  "static" => (),
  "as" => (),
  "break" => (),
  "crate" => (),
  "else" => (),
  "enum" => (),
  "extern" => (),
  "false" => (),
  "fn" => (),
  "for" => (),
  "if" => (),
  "impl" => (),
  "in" => (),
  "let" => (),
  "loop" => (),
  "match" => (),
  "mod" => (),
  "move" => (),
  "mut" => (),
  "priv" => (),
  "pub" => (),
  "ref" => (),
  "return" => (),
  "struct" => (),
  "true" => (),
  "trait" => (),
  "type" => (),
  "unsafe" => (),
  "use" => (),
  "while" => (),
  "continue" => (),
  "box" => (),
  "const" => (),
  "where" => (),
  "typeof" => (),
  INNER_DOC_COMMENT => (),
  OUTER_DOC_COMMENT => (),
  SHEBANG => (),
  "'static" => (),
  ";" => (),
  "," => (),
  "." => (),
  "@" => (),
  "#" => (),
  "~" => (),
  ":" => (),
  "$" => (),
  "=" => (),
  "?" => (),
  "!" => (),
  "<" => (),
  ">" => (),
  "-" => (),
  "&" => (),
  "|+" => (),
  "|1" => (),
  "+" => (),
  "*" => (),
  "/" => (),
  "^" => (),
  "%" => (),
};
token_trees: () = {
  () => (),
  token_trees token_tree => (),
};
token_tree: () = {
  delimited_token_trees => (),
  unpaired_token => (),
};
delimited_token_trees: () = {
  parens_delimited_token_trees => (),
  braces_delimited_token_trees => (),
  brackets_delimited_token_trees => (),
};
parens_delimited_token_trees: () = {
  "(" token_trees ")" => (),
};
braces_delimited_token_trees: () = {
  "{" token_trees "}" => (),
};
brackets_delimited_token_trees: () = {
  "[" token_trees "]" => (),
};

maybe_ident: () = {
  () => (),
  ident => (),
};

#[inline]
Comma<E>: () =
    Delim<E,",">;

#[inline]
Delim<E,D>: () =
    <v0:(<E> D)*> <e1:E?> => ();

#[inline]
OROR: () =
    "|+" "|1";

#[inline]
AnyPipe: () = {
    "|+" => (),
    "|1" => (),
};

extern {
    enum &'input str {
        "!" => Token0,
        "#" => Token1,
        "$" => Token2,
        "%" => Token3,
        "&" => Token4,
        "(" => Token5,
        ")" => Token6,
        "*" => Token7,
        "+" => Token8,
        "," => Token9,
        "-" => Token10,
        "." => Token11,
        "/" => Token12,
        ":" => Token13,
        ";" => Token14,
        "<" => Token15,
        "=" => Token16,
        ">" => Token17,
        "?" => Token18,
        "@" => Token19,
        "[" => Token20,
        "]" => Token21,
        "^" => Token22,
        "{" => Token23,
        "|+" => Token24a,  // "|" followed immediately by another "|"
        "|1" => Token24b,  // "|" followed by non-pipe
        "}" => Token25,
        "~" => Token26,
        SHL => Token27,
        SHR => Token28,
        LE => Token29,
        EQEQ => Token30,
        NE => Token31,
        GE => Token32,
        ANDAND => Token33,
        "<<=" => Token35,
        ">>=" => Token36,
        "-=" => Token37,
        "&=" => Token38,
        "|=" => Token39,
        "+=" => Token40,
        "*=" => Token41,
        "/=" => Token42,
        "^=" => Token43,
        "%=" => Token44,
        ".." => Token45,
        "..." => Token46,
        "::" => Token47,
        "->" => Token48,
        "=>" => Token48b,
        "<-" => Token49,
        LIT_BYTE => Token51,
        LIT_CHAR => Token52,
        LIT_INTEGER => Token53,
        LIT_FLOAT => Token54,
        LIT_STR => Token55,
        LIT_STR_RAW => Token56,
        LIT_BYTE_STR => Token57,
        LIT_BYTE_STR_RAW => Token58,
        IDENT => Token59,
        UNDERSCORE => Token60,
        LIFETIME => Token61,
        "self" => Token62,
        "static" => Token63,
        "as" => Token64,
        "break" => Token65,
        "crate" => Token66,
        "else" => Token67,
        "enum" => Token68,
        "extern" => Token69,
        "false" => Token70,
        "fn" => Token71,
        "for" => Token72,
        "if" => Token73,
        "impl" => Token74,
        "in" => Token75,
        "let" => Token76,
        "loop" => Token77,
        "match" => Token78,
        "mod" => Token79,
        "move" => Token80,
        "mut" => Token81,
        "priv" => Token82,
        "pub" => Token83,
        "ref" => Token84,
        "return" => Token85,
        "struct" => Token86,
        "true" => Token87,
        "trait" => Token88,
        "type" => Token89,
        "unsafe" => Token90,
        "use" => Token91,
        "while" => Token92,
        "continue" => Token93,
        "box" => Token95,
        "const" => Token96,
        "where" => Token97,
        "typeof" => Token98,
        INNER_DOC_COMMENT => Token99,
        OUTER_DOC_COMMENT => Token100,
        SHEBANG => Token101,
        SHEBANG_LINE => Token102,
        "'static" => Token103,
    }
}
