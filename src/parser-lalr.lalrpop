grammar;
pub crate: () = {
  shebang? inner_attr* mod_item* => (),
};
shebang: () = {
  SHEBANG_LINE => (),
};
inner_attr: () = {
  SHEBANG "[" meta_item "]" => (),
  INNER_DOC_COMMENT => (),
};
maybe_outer_attrs: () = {
  outer_attrs => (),
  () => (),
};
outer_attrs: () = {
  outer_attr => (),
  outer_attrs outer_attr => (),
};
outer_attr: () = {
  "#" "[" meta_item "]" => (),
  OUTER_DOC_COMMENT => (),
};
meta_item: () = {
  ident => (),
  ident "=" lit => (),
  ident "(" Comma<meta_item> ")" => (),
};
meta_seq: () = {
  () => (),
  meta_item => (),
  meta_seq "," meta_item => (),
};
attrs_and_vis: () = {
  maybe_outer_attrs visibility => (),
};
mod_item: () = {
  attrs_and_vis item => (),
};
item: () = {
  stmt_item => (),
  item_macro => (),
};
stmt_item: () = {
  item_static => (),
  item_const => (),
  item_type => (),
  block_item => (),
  view_item => (),
};
item_static: () = {
  STATIC ident ":" ty "=" expr ";" => (),
  STATIC MUT ident ":" ty "=" expr ";" => (),
};
item_const: () = {
  CONST ident ":" ty "=" expr ";" => (),
};
item_macro: () = {
  PathExpr "!" ident? parens_delimited_token_trees ";" => (),
  PathExpr "!" ident? braces_delimited_token_trees => (),
  PathExpr "!" ident? brackets_delimited_token_trees ";" => (),
};
view_item: () = {
  use_item => (),
  extern_fn_item => (),
  EXTERN CRATE ident ";" => (),
  EXTERN CRATE ident AS ident ";" => (),
};
extern_fn_item: () = {
  EXTERN abi? item_fn => (),
};
use_item: () = {
  USE view_path ";" => (),
};
view_path: () = {
  path_no_types_allowed => (),
  path_no_types_allowed MOD_SEP "{" "}" => (),
  MOD_SEP "{" "}" => (),
  path_no_types_allowed MOD_SEP "{" idents_or_self "}" => (),
  MOD_SEP "{" idents_or_self "}" => (),
  path_no_types_allowed MOD_SEP "{" idents_or_self "," "}" => (),
  MOD_SEP "{" idents_or_self "," "}" => (),
  path_no_types_allowed MOD_SEP "*" => (),
  "{" "}" => (),
  "{" idents_or_self "}" => (),
  "{" idents_or_self "," "}" => (),
  path_no_types_allowed AS ident => (),
};
block_item: () = {
  item_fn => (),
  item_unsafe_fn => (),
  item_mod => (),
  item_foreign_mod => (),
  item_struct => (),
  item_enum => (),
  item_trait => (),
  item_impl => (),
};
maybe_ty_ascription: () = {
  ":" ty_sum => (),
  () => (),
};
maybe_init_expr: () = {
  "=" expr => (),
  () => (),
};
item_struct: () = {
  STRUCT ident generic_params maybe_where_clause struct_decl_args => (),
  STRUCT ident generic_params struct_tuple_args maybe_where_clause ";" => (),
  STRUCT ident generic_params maybe_where_clause ";" => (),
};
struct_decl_args: () = {
  "{" struct_decl_fields "}" => (),
  "{" struct_decl_fields "," "}" => (),
};
struct_tuple_args: () = {
  "(" struct_tuple_fields ")" => (),
  "(" struct_tuple_fields "," ")" => (),
};
struct_decl_fields: () = {
  struct_decl_field => (),
  struct_decl_fields "," struct_decl_field => (),
  () => (),
};
struct_decl_field: () = {
  attrs_and_vis ident ":" ty_sum => (),
};
struct_tuple_fields: () = {
  struct_tuple_field => (),
  struct_tuple_fields "," struct_tuple_field => (),
};
struct_tuple_field: () = {
  attrs_and_vis ty_sum => (),
};
item_enum: () = {
  ENUM ident generic_params maybe_where_clause "{" enum_defs "}" => (),
  ENUM ident generic_params maybe_where_clause "{" enum_defs "," "}" => (),
};
enum_defs: () = {
  enum_def => (),
  enum_defs "," enum_def => (),
  () => (),
};
enum_def: () = {
  attrs_and_vis ident enum_args => (),
};
enum_args: () = {
  "{" struct_decl_fields "}" => (),
  "{" struct_decl_fields "," "}" => (),
  "(" maybe_ty_sums ")" => (),
  "=" expr => (),
  () => (),
};
item_mod: () = {
  MOD ident ";" => (),
  MOD ident "{" inner_attr* mod_item* "}" => (),
};
item_foreign_mod: () = {
  EXTERN abi? "{" inner_attr* foreign_item* "}" => (),
};
abi: () = {
  str => (),
};
foreign_item: () = {
  attrs_and_vis STATIC item_foreign_static => (),
  attrs_and_vis item_foreign_fn => (),
  attrs_and_vis UNSAFE item_foreign_fn => (),
};
item_foreign_static: () = {
  maybe_mut ident ":" ty ";" => (),
};
item_foreign_fn: () = {
  FN ident generic_params fn_decl_allow_variadic maybe_where_clause ";" => (),
};
fn_decl_allow_variadic: () = {
  fn_params_allow_variadic ret_ty => (),
};
fn_params_allow_variadic: () = {
  "(" ")" => (),
  "(" params ")" => (),
  "(" params "," ")" => (),
  "(" params "," DOTDOTDOT ")" => (),
};
visibility: () = {
  PUB => (),
  () => (),
};
idents_or_self: () = {
  ident_or_self => (),
  ident_or_self AS ident => (),
  idents_or_self "," ident_or_self => (),
};
ident_or_self: () = {
  ident => (),
  SELF => (),
};
item_type: () = {
  TYPE ident generic_params maybe_where_clause "=" ty_sum ";" => (),
};
for_sized: () = {
  FOR "?" ident => (),
  FOR ident "?" => (),
  () => (),
};
item_trait: () = {
  maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause "{" maybe_trait_items "}" => (),
};
maybe_trait_items: () = {
  trait_items => (),
  () => (),
};
trait_items: () = {
  trait_item => (),
  trait_items trait_item => (),
};
trait_item: () = {
  trait_const => (),
  trait_type => (),
  trait_method => (),
};
trait_const: () = {
  maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ";" => (),
};
maybe_const_default: () = {
  "=" expr => (),
  () => (),
};
trait_type: () = {
  maybe_outer_attrs TYPE ty_param ";" => (),
};
maybe_unsafe: () = {
  UNSAFE => (),
  () => (),
};
trait_method: () = {
  type_method => (),
  method => (),
};
type_method: () = {
  attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ";" => (),
  attrs_and_vis maybe_unsafe EXTERN abi? FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ";" => (),
};
method: () = {
  attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block => (),
  attrs_and_vis maybe_unsafe EXTERN abi? FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block => (),
};
impl_method: () = {
  attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block => (),
  attrs_and_vis maybe_unsafe EXTERN abi? FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block => (),
};
item_impl: () = {
  maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe IMPL generic_params "(" ty ")" maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe IMPL generic_params "!" trait_ref FOR ty_sum maybe_where_clause "{" inner_attr* maybe_impl_items "}" => (),
  maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT "{" "}" => (),
  maybe_unsafe IMPL generic_params "!" trait_ref FOR DOTDOT "{" "}" => (),
};
maybe_impl_items: () = {
  impl_items => (),
  () => (),
};
impl_items: () = {
  impl_item => (),
  impl_item impl_items => (),
};
impl_item: () = {
  impl_method => (),
  attrs_and_vis item_macro => (),
  impl_const => (),
  impl_type => (),
};
impl_const: () = {
  attrs_and_vis item_const => (),
};
impl_type: () = {
  attrs_and_vis TYPE ident generic_params "=" ty_sum ";" => (),
};
item_fn: () = {
  FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block => (),
};
item_unsafe_fn: () = {
  UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block => (),
  UNSAFE EXTERN abi? FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block => (),
};
fn_decl: () = {
  fn_params ret_ty => (),
};
fn_decl_with_self: () = {
  fn_params_with_self ret_ty => (),
};
fn_decl_with_self_allow_anon_params: () = {
  fn_anon_params_with_self ret_ty => (),
};
fn_params: () = {
  "(" maybe_params ")" => (),
};
fn_anon_params: () = {
  "(" anon_param anon_params_allow_variadic_tail ")" => (),
  "(" ")" => (),
};
fn_params_with_self: () = {
  "(" maybe_mut SELF maybe_ty_ascription maybe_comma_params ")" => (),
  "(" "&" maybe_mut SELF maybe_ty_ascription maybe_comma_params ")" => (),
  "(" "&" lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ")" => (),
  "(" maybe_params ")" => (),
};
fn_anon_params_with_self: () = {
  "(" maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ")" => (),
  "(" "&" maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ")" => (),
  "(" "&" lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ")" => (),
  "(" maybe_anon_params ")" => (),
};
maybe_params: () = {
  params => (),
  params "," => (),
  () => (),
};
params: () = {
  param => (),
  params "," param => (),
};
param: () = {
  Pat ":" ty_sum => (),
};
inferrable_param: () = {
  Pat maybe_ty_ascription => (),
};
maybe_unboxed_closure_kind: () = {
  () => (),
  ":" => (),
  "&" maybe_mut ":" => (),
};
maybe_comma_params: () = {
  "," => (),
  "," params => (),
  "," params "," => (),
  () => (),
};
maybe_comma_anon_params: () = {
  "," => (),
  "," anon_params => (),
  "," anon_params "," => (),
  () => (),
};
maybe_anon_params: () = {
  anon_params => (),
  anon_params "," => (),
  () => (),
};
anon_params: () = {
  anon_param => (),
  anon_params "," anon_param => (),
};
anon_param: () = {
  named_arg ":" ty => (),
  ty => (),
};
anon_params_allow_variadic_tail: () = {
  "," DOTDOTDOT => (),
  "," anon_param anon_params_allow_variadic_tail => (),
  () => (),
};
named_arg: () = {
  ident => (),
  UNDERSCORE => (),
  "&" ident => (),
  "&" UNDERSCORE => (),
  ANDAND ident => (),
  ANDAND UNDERSCORE => (),
  MUT ident => (),
};
ret_ty: () = {
  RARROW "!" => (),
  RARROW ty => (),
  () => (),
};
generic_params: () = {
  "<" lifetimes ">" => (),
  "<" lifetimes "," ">" => (),
  "<" lifetimes SHR => (),
  "<" lifetimes "," SHR => (),
  "<" lifetimes "," ty_params ">" => (),
  "<" lifetimes "," ty_params "," ">" => (),
  "<" lifetimes "," ty_params SHR => (),
  "<" lifetimes "," ty_params "," SHR => (),
  "<" ty_params ">" => (),
  "<" ty_params "," ">" => (),
  "<" ty_params SHR => (),
  "<" ty_params "," SHR => (),
  () => (),
};
maybe_where_clause: () = {
  () => (),
  where_clause => (),
};
where_clause: () = {
  WHERE where_predicates => (),
  WHERE where_predicates "," => (),
};
where_predicates: () = {
  where_predicate => (),
  where_predicates "," where_predicate => (),
};
where_predicate: () = {
  for_lifetimes? lifetime ":" bounds => (),
  for_lifetimes ty ":" ty_param_bounds => (),
};
for_lifetimes: () = {
  FOR "<" lifetimes ">" => (),
};
ty_params: () = {
  ty_param => (),
  ty_params "," ty_param => (),
};
path_no_types_allowed: () = {
  ident => (),
  MOD_SEP ident => (),
  SELF => (),
  MOD_SEP SELF => (),
  path_no_types_allowed MOD_SEP ident => (),
};
path_generic_args_without_colons: () = {
  ident => (),
  ident generic_args => (),
  ident "(" maybe_ty_sums ")" ret_ty => (),
  path_generic_args_without_colons MOD_SEP ident => (),
  path_generic_args_without_colons MOD_SEP ident generic_args => (),
  path_generic_args_without_colons MOD_SEP ident "(" maybe_ty_sums ")" ret_ty => (),
};
generic_args: () = {
  "<" generic_values ">" => (),
  "<" generic_values SHR => (),
  "<" generic_values GE => (),
  "<" generic_values SHREQ => (),
  SHL ty_qualified_path_and_generic_values ">" => (),
  SHL ty_qualified_path_and_generic_values SHR => (),
  SHL ty_qualified_path_and_generic_values GE => (),
  SHL ty_qualified_path_and_generic_values SHREQ => (),
};
generic_values: () = {
  maybe_lifetimes maybe_ty_sums_and_or_bindings => (),
};
maybe_ty_sums_and_or_bindings: () = {
  ty_sums => (),
  ty_sums "," => (),
  ty_sums "," bindings => (),
  bindings => (),
  bindings "," => (),
  () => (),
};
maybe_bindings: () = {
  "," bindings => (),
  () => (),
};
Pat: () = {
  UNDERSCORE => (),
  "&" Pat => (),
  "&" MUT Pat => (),
  ANDAND Pat => (),
  "(" ")" => (),
  "(" PatTup ")" => (),
  "(" PatTup "," ")" => (),
  "[" PatVec "]" => (),
  lit_or_path => (),
  lit_or_path DOTDOTDOT lit_or_path => (),
  PathExpr "{" PatStruct "}" => (),
  PathExpr "(" DOTDOT ")" => (),
  PathExpr "(" PatTup ")" => (),
  PathExpr "!" ident? delimited_token_trees => (),
  binding_mode ident => (),
  ident "@" Pat => (),
  binding_mode ident "@" Pat => (),
  BOX Pat => (),
  "<" ty_sum maybe_as_trait_ref ">" MOD_SEP ident => (),
  SHL ty_sum maybe_as_trait_ref ">" MOD_SEP ident maybe_as_trait_ref ">" MOD_SEP ident => (),
};
pats_or: () = {
  Pat => (),
  pats_or "|1" Pat => (),
};
binding_mode: () = {
  REF => (),
  REF MUT => (),
  MUT => (),
};
lit_or_path: () = {
  PathExpr => (),
  lit => (),
  "-" lit => (),
};
PatField: () = {
  ident => (),
  binding_mode ident => (),
  BOX ident => (),
  BOX binding_mode ident => (),
  ident ":" Pat => (),
  binding_mode ident ":" Pat => (),
};
PatFields: () = {
  PatField => (),
  PatFields "," PatField => (),
};
PatStruct: () = {
  PatFields => (),
  PatFields "," => (),
  PatFields "," DOTDOT => (),
  DOTDOT => (),
};
PatTup: () = {
  Pat => (),
  PatTup "," Pat => (),
};
PatVec: () = {
  PatVec_elts => (),
  PatVec_elts "," => (),
  PatVec_elts DOTDOT => (),
  PatVec_elts "," DOTDOT => (),
  PatVec_elts DOTDOT "," PatVec_elts => (),
  PatVec_elts DOTDOT "," PatVec_elts "," => (),
  PatVec_elts "," DOTDOT "," PatVec_elts => (),
  PatVec_elts "," DOTDOT "," PatVec_elts "," => (),
  DOTDOT "," PatVec_elts => (),
  DOTDOT "," PatVec_elts "," => (),
  DOTDOT => (),
  () => (),
};
PatVec_elts: () = {
  Pat => (),
  PatVec_elts "," Pat => (),
};
ty: () = {
  ty_prim => (),
  "<" ty_sum maybe_as_trait_ref ">" MOD_SEP ident => (),
  SHL ty_sum maybe_as_trait_ref ">" MOD_SEP ident maybe_as_trait_ref ">" MOD_SEP ident => (),
  "(" ty_sums ")" => (),
  "(" ty_sums "," ")" => (),
  "(" ")" => (),
};
ty_prim: () = {
  path_generic_args_without_colons => (),
  MOD_SEP path_generic_args_without_colons => (),
  SELF MOD_SEP path_generic_args_without_colons => (),
  BOX ty => (),
  "*" maybe_mut_or_const ty => (),
  "&" ty => (),
  "&" MUT ty => (),
  ANDAND ty => (),
  ANDAND MUT ty => (),
  "&" lifetime maybe_mut ty => (),
  ANDAND lifetime maybe_mut ty => (),
  "[" ty "]" => (),
  "[" ty "," DOTDOT expr "]" => (),
  "[" ty ";" expr "]" => (),
  TYPEOF "(" expr ")" => (),
  UNDERSCORE => (),
  ty_bare_fn => (),
  for_in_type => (),
};
ty_bare_fn: () = {
  FN ty_fn_decl => (),
  UNSAFE FN ty_fn_decl => (),
  EXTERN abi? FN ty_fn_decl => (),
  UNSAFE EXTERN abi? FN ty_fn_decl => (),
};
ty_fn_decl: () = {
  generic_params fn_anon_params ret_ty => (),
};
for_in_type: () = {
  FOR "<" maybe_lifetimes ">" for_in_type_suffix => (),
};
for_in_type_suffix: () = {
  ty_bare_fn => (),
  trait_ref => (),
};
maybe_mut: () = {
  MUT => (),
  () => (),
};
maybe_mut_or_const: () = {
  MUT => (),
  CONST => (),
  () => (),
};
ty_qualified_path_and_generic_values: () = {
  ty_qualified_path maybe_bindings => (),
  ty_qualified_path "," ty_sums maybe_bindings => (),
};
ty_qualified_path: () = {
  ty_sum AS trait_ref ">" MOD_SEP ident => (),
  ty_sum AS trait_ref ">" MOD_SEP ident "+" ty_param_bounds => (),
};
maybe_ty_sums: () = {
  ty_sums => (),
  ty_sums "," => (),
  () => (),
};
ty_sums: () = {
  ty_sum => (),
  ty_sums "," ty_sum => (),
};
ty_sum: () = {
  ty => (),
  ty "+" ty_param_bounds => (),
};
ty_prim_sum: () = {
  ty_prim => (),
  ty_prim "+" ty_param_bounds => (),
};
maybe_ty_param_bounds: () = {
  ":" ty_param_bounds => (),
  () => (),
};
ty_param_bounds: () = {
  boundseq => (),
  () => (),
};
boundseq: () = {
  polybound => (),
  boundseq "+" polybound => (),
};
polybound: () = {
  FOR "<" maybe_lifetimes ">" bound => (),
  bound => (),
  "?" bound => (),
};
bindings: () = {
  binding => (),
  bindings "," binding => (),
};
binding: () = {
  ident "=" ty => (),
};
ty_param: () = {
  ident maybe_ty_param_bounds maybe_ty_default => (),
  ident "?" ident maybe_ty_param_bounds maybe_ty_default => (),
};
maybe_bounds: () = {
  ":" bounds => (),
  () => (),
};
bounds: () = {
  bound => (),
  bounds "+" bound => (),
};
bound: () = {
  lifetime => (),
  trait_ref => (),
};
maybe_ltbounds: () = {
  ":" ltbounds => (),
  () => (),
};
ltbounds: () = {
  lifetime => (),
  ltbounds "+" lifetime => (),
};
maybe_ty_default: () = {
  "=" ty_sum => (),
  () => (),
};
maybe_lifetimes: () = {
  lifetimes => (),
  lifetimes "," => (),
  () => (),
};
lifetimes: () = {
  lifetime_and_bounds => (),
  lifetimes "," lifetime_and_bounds => (),
};
lifetime_and_bounds: () = {
  LIFETIME maybe_ltbounds => (),
  STATIC_LIFETIME => (),
};
lifetime: () = {
  LIFETIME => (),
  STATIC_LIFETIME => (),
};
trait_ref: () = {
  path_generic_args_without_colons => (),
  MOD_SEP path_generic_args_without_colons => (),
};
inner_attrs_and_block: () = {
  "{" inner_attr* maybe_stmts "}" => (),
};
block: () = {
  "{" maybe_stmts "}" => (),
};
maybe_stmts: () = {
  stmts => (),
  stmts nonblock_expr => (),
  nonblock_expr => (),
  () => (),
};
stmts: () = {
  stmt => (),
  stmts stmt => (),
};
stmt: () = {
  let => (),
  stmt_item => (),
  PUB stmt_item => (),
  outer_attrs stmt_item => (),
  outer_attrs PUB stmt_item => (),
  full_block_expr => (),
  block => (),
  nonblock_expr ";" => (),
  ";" => (),
};
maybe_exprs: () = {
  exprs => (),
  exprs "," => (),
  () => (),
};
maybe_expr: () = {
  expr => (),
  () => (),
};
exprs: () = {
  expr => (),
  exprs "," expr => (),
};
PathExpr: () = {
  path_generic_args_with_colons => (),
  MOD_SEP path_generic_args_with_colons => (),
  SELF MOD_SEP path_generic_args_with_colons => (),
};
path_generic_args_with_colons: () = {
  ident => (),
  path_generic_args_with_colons MOD_SEP ident => (),
  path_generic_args_with_colons MOD_SEP generic_args => (),
};
MacroExpr: () = {
  PathExpr "!" ident? parens_delimited_token_trees => (),
  PathExpr "!" ident? brackets_delimited_token_trees => (),
};

// Old-style names:
expr: () = Expr<"">;
expr_nostruct: () = Expr<"nostruct">;
nonblock_expr: () = Expr<"nonblock">;
nonparen_expr: () = Expr<"nonparen">;

// New-style names:
Expression: () = Expr<"">;

// "V" is the Expr "Variant", and is intended to be a list of
// restrictions, e.g.:
//
// - "" -- most general form of expressions
// - "nonblock"
// - "nonparen"
// - "nostruct"
// - "nonblock,nonparen"
// - "norange"
//
// etc.
Expr<V>: () = {
    ExprAssign<V>,
    "return" => (),
    "return" Expr<V> => (),
};

ExprAssign<V>: () = {
    ExprEmplace<V> => (),
    ExprEmplace<V> "=" ExprAssign<V> => (),
    ExprEmplace<V> SHLEQ ExprAssign<V> => (),
    ExprEmplace<V> SHREQ ExprAssign<V> => (),
    ExprEmplace<V> MINUSEQ ExprAssign<V> => (),
    ExprEmplace<V> ANDEQ ExprAssign<V> => (),
    ExprEmplace<V> OREQ ExprAssign<V> => (),
    ExprEmplace<V> PLUSEQ ExprAssign<V> => (),
    ExprEmplace<V> STAREQ ExprAssign<V> => (),
    ExprEmplace<V> SLASHEQ ExprAssign<V> => (),
    ExprEmplace<V> CARETEQ ExprAssign<V> => (),
    ExprEmplace<V> PERCENTEQ ExprAssign<V> => (),
};

ExprEmplace<V>: () = {
    ExprJustRange<V>,
    ExprJustRange<V> LARROW ExprEmplace<V> => (),
};

ExprJustRange<V>: () = {
    ExprPostRange<V>,
    DOTDOT => (),
};

// Placeholder for whatever has higher precedence than `..` by itself.
ExprPostRange<V>: () = {
    ExprOrOr<V>
};

ExprOrOr<V>: () = {
    ExprAndAnd<V>,
    ExprOrOr<V> OROR ExprAndAnd<V> => (),
};

ExprAndAnd<V>: () = {
    ExprEq<V>,
    ExprAndAnd<V> ANDAND ExprEq<V> => (),
};

ExprEq<V>: () = {
    ExprComparison<V>,
    ExprEq<V> EQEQ ExprComparison<V> => (),
    ExprEq<V> NE ExprComparison<V> => (),
};

ExprComparison<V>: () = {
    ExprOr<V>,
    ExprComparison<V> "<" ExprOr<V> => (),
    ExprComparison<V> ">" ExprOr<V> => (),
    ExprComparison<V> LE ExprOr<V> => (),
    ExprComparison<V> GE ExprOr<V> => (),
};

ExprOr<V>: () = {
    ExprXor<V>,
    ExprOr<V> "|1" ExprXor<V> => (),
};

ExprXor<V>: () = {
    ExprAnd<V>,
    ExprXor<V> "^" ExprAnd<V> => (),
};

ExprAnd<V>: () = {
    ExprShift<V>,
    ExprAnd<V> "&" ExprShift<V> => (),
};

ExprShift<V>: () = {
    ExprPlusMinus<V>,
    ExprShift<V> SHL ExprPlusMinus<V> => (),
    ExprShift<V> SHR ExprPlusMinus<V> => (),
};

ExprPlusMinus<V>: () = {
    ExprAs<V>,
    ExprPlusMinus<V> "+" ExprAs<V> => (),
    ExprPlusMinus<V> "-" ExprAs<V> => (),
};

ExprAs<V>: () = {
    ExprMulDiv<V>,
    ExprAs<V> AS ExprMulDiv<V> => (),
};

ExprMulDiv<V>: () = {
    ExprRange<V>,
    ExprMulDiv<V> "*" ExprRange<V> => (),
    ExprMulDiv<V> "/" ExprRange<V> => (),
    ExprMulDiv<V> "%" ExprRange<V> => (),
};

// FIXE
ExprRange<V>: () = {
    ExprSuffix<V>,
    ExprSuffix<V> DOTDOT => (),
    ExprSuffix<V> DOTDOT ExprPostRange<V> => (),
    DOTDOT ExprRange<V> => (),
};

ExprSuffix<V>: () = {
    ExprAtom<V>,
    ExprSuffix<V> "." path_generic_args_with_colons => (),
    ExprSuffix<V> "." LIT_INTEGER => (),
    ExprSuffix<V> "[" Expression "]" => (),
    ExprSuffix<V> "(" Comma<Expression> ")" => (),
};

ExprPrefix<V>: () = {
    BOX ExprPrefix<V> => (),
    "-" ExprPrefix<V> => (),
    "!" ExprPrefix<V> => (),
    "*" ExprPrefix<V> => (),
    "&" maybe_mut ExprPrefix<V> => (),
};

ExprAtom<V>: () = {
    lit => (),
    PathExpr => (),
    SELF => (),
    MacroExpr => (),
    PathExpr "{" struct_expr_fields "}" => (),
    "(" Comma<Expression> ")" => (),
    "[" Comma<Expression> "]" => (),
    "[" Expression ";" Expression "]" => (),
    "continue" => (),
    "continue" ident => (),
    "break" => (),
    "break" ident => (),
    expr_qualified_path => (),
    block_expr => (),
    block => (),
    ANDAND maybe_mut Expr<V> => (),
    LambdaExpr<V> => (),
    MOVE LambdaExpr<V> => (),
};

expr_qualified_path: () = {
  "<" ty_sum maybe_as_trait_ref ">" MOD_SEP ident maybe_qpath_params => (),
  SHL ty_sum maybe_as_trait_ref ">" MOD_SEP ident maybe_as_trait_ref ">" MOD_SEP ident => (),
  SHL ty_sum maybe_as_trait_ref ">" MOD_SEP ident generic_args maybe_as_trait_ref ">" MOD_SEP ident => (),
  SHL ty_sum maybe_as_trait_ref ">" MOD_SEP ident maybe_as_trait_ref ">" MOD_SEP ident generic_args => (),
  SHL ty_sum maybe_as_trait_ref ">" MOD_SEP ident generic_args maybe_as_trait_ref ">" MOD_SEP ident generic_args => (),
};
maybe_qpath_params: () = {
  MOD_SEP generic_args => (),
  () => (),
};
maybe_as_trait_ref: () = {
  AS trait_ref => (),
  () => (),
};
LambdaExpr<V>: () = {
    AnyPipe Comma<inferrable_param>? "|1" Expr<V> => (),
    AnyPipe Comma<inferrable_param>? "|1" "->" ty "{" Expr<V> "}" => (),
};
struct_expr_fields: () = {
  field_inits => (),
  field_inits "," => (),
  maybe_field_inits default_field_init => (),
};
maybe_field_inits: () = {
  field_inits => (),
  field_inits "," => (),
  () => (),
};
field_inits: () = {
  field_init => (),
  field_inits "," field_init => (),
};
field_init: () = {
  ident ":" expr => (),
};
default_field_init: () = {
  DOTDOT expr => (),
};
block_expr: () = {
  expr_match => (),
  expr_if => (),
  expr_if_let => (),
  expr_while => (),
  expr_while_let => (),
  expr_loop => (),
  expr_for => (),
  UNSAFE block => (),
  PathExpr "!" ident? braces_delimited_token_trees => (),
};
full_block_expr: () = {
  block_expr => (),
  full_block_expr "." path_generic_args_with_colons => (),
  full_block_expr "." path_generic_args_with_colons "[" maybe_expr "]" => (),
  full_block_expr "." path_generic_args_with_colons "(" maybe_exprs ")" => (),
  full_block_expr "." LIT_INTEGER => (),
};
expr_match: () = {
  MATCH expr_nostruct "{" "}" => (),
  MATCH expr_nostruct "{" match_clauses "}" => (),
  MATCH expr_nostruct "{" match_clauses nonblock_match_clause "}" => (),
  MATCH expr_nostruct "{" nonblock_match_clause "}" => (),
};
match_clauses: () = {
  match_clause => (),
  match_clauses match_clause => (),
};
match_clause: () = {
  nonblock_match_clause "," => (),
  block_match_clause => (),
  block_match_clause "," => (),
};
nonblock_match_clause: () = {
  maybe_outer_attrs pats_or maybe_guard "->" nonblock_expr => (),
  maybe_outer_attrs pats_or maybe_guard "->" full_block_expr => (),
};
block_match_clause: () = {
  maybe_outer_attrs pats_or maybe_guard "->" block => (),
};
maybe_guard: () = {
  IF expr_nostruct => (),
  () => (),
};
expr_if: () = {
  IF expr_nostruct block => (),
  IF expr_nostruct block ELSE block_or_if => (),
};
expr_if_let: () = {
  IF LET Pat "=" expr_nostruct block => (),
  IF LET Pat "=" expr_nostruct block ELSE block_or_if => (),
};
block_or_if: () = {
  block => (),
  expr_if => (),
  expr_if_let => (),
};
expr_while: () = {
  maybe_label WHILE expr_nostruct block => (),
};
expr_while_let: () = {
  maybe_label WHILE LET Pat "=" expr_nostruct block => (),
};
expr_loop: () = {
  maybe_label LOOP block => (),
};
expr_for: () = {
  maybe_label FOR Pat IN expr_nostruct block => (),
};
maybe_label: () = {
  lifetime ":" => (),
  () => (),
};
let: () = {
  LET Pat maybe_ty_ascription maybe_init_expr ";" => (),
};
lit: () = {
  LIT_BYTE => (),
  LIT_CHAR => (),
  LIT_INTEGER => (),
  LIT_FLOAT => (),
  TRUE => (),
  FALSE => (),
  str => (),
};
str: () = {
  LIT_STR => (),
  LIT_STR_RAW => (),
  LIT_BYTE_STR => (),
  LIT_BYTE_STR_RAW => (),
};
ident: () = {
  IDENT => (),
};
unpaired_token: () = {
  SHL => (),
  SHR => (),
  LE => (),
  EQEQ => (),
  NE => (),
  GE => (),
  ANDAND => (),
  LARROW => (),
  SHLEQ => (),
  SHREQ => (),
  MINUSEQ => (),
  ANDEQ => (),
  OREQ => (),
  PLUSEQ => (),
  STAREQ => (),
  SLASHEQ => (),
  CARETEQ => (),
  PERCENTEQ => (),
  DOTDOT => (),
  DOTDOTDOT => (),
  MOD_SEP => (),
  RARROW => (),
  "->" => (),
  LIT_BYTE => (),
  LIT_CHAR => (),
  LIT_INTEGER => (),
  LIT_FLOAT => (),
  LIT_STR => (),
  LIT_STR_RAW => (),
  LIT_BYTE_STR => (),
  LIT_BYTE_STR_RAW => (),
  IDENT => (),
  UNDERSCORE => (),
  LIFETIME => (),
  SELF => (),
  STATIC => (),
  AS => (),
  "break" => (),
  CRATE => (),
  ELSE => (),
  ENUM => (),
  EXTERN => (),
  FALSE => (),
  FN => (),
  FOR => (),
  IF => (),
  IMPL => (),
  IN => (),
  LET => (),
  LOOP => (),
  MATCH => (),
  MOD => (),
  MOVE => (),
  MUT => (),
  PRIV => (),
  PUB => (),
  REF => (),
  "return" => (),
  STRUCT => (),
  TRUE => (),
  TRAIT => (),
  TYPE => (),
  UNSAFE => (),
  USE => (),
  WHILE => (),
  "continue" => (),
  BOX => (),
  CONST => (),
  WHERE => (),
  TYPEOF => (),
  INNER_DOC_COMMENT => (),
  OUTER_DOC_COMMENT => (),
  SHEBANG => (),
  STATIC_LIFETIME => (),
  ";" => (),
  "," => (),
  "." => (),
  "@" => (),
  "#" => (),
  "~" => (),
  ":" => (),
  "$" => (),
  "=" => (),
  "?" => (),
  "!" => (),
  "<" => (),
  ">" => (),
  "-" => (),
  "&" => (),
  "|+" => (),
  "|1" => (),
  "+" => (),
  "*" => (),
  "/" => (),
  "^" => (),
  "%" => (),
};
token_trees: () = {
  () => (),
  token_trees token_tree => (),
};
token_tree: () = {
  delimited_token_trees => (),
  unpaired_token => (),
};
delimited_token_trees: () = {
  parens_delimited_token_trees => (),
  braces_delimited_token_trees => (),
  brackets_delimited_token_trees => (),
};
parens_delimited_token_trees: () = {
  "(" token_trees ")" => (),
};
braces_delimited_token_trees: () = {
  "{" token_trees "}" => (),
};
brackets_delimited_token_trees: () = {
  "[" token_trees "]" => (),
};

maybe_ident: () = {
  () => (),
  ident => (),
};

#[inline]
Comma<E>: () =
    Delim<E,",">;

#[inline]
Delim<E,D>: () =
    <v0:(<E> D)*> <e1:E?> => ();

#[inline]
OROR: () =
    "|+" "|1";

#[inline]
AnyPipe: () = {
    "|+" => (),
    "|1" => (),
};

extern {
    enum &'input str {
        "!" => Token0,
        "#" => Token1,
        "$" => Token2,
        "%" => Token3,
        "&" => Token4,
        "(" => Token5,
        ")" => Token6,
        "*" => Token7,
        "+" => Token8,
        "," => Token9,
        "-" => Token10,
        "." => Token11,
        "/" => Token12,
        ":" => Token13,
        ";" => Token14,
        "<" => Token15,
        "=" => Token16,
        ">" => Token17,
        "?" => Token18,
        "@" => Token19,
        "[" => Token20,
        "]" => Token21,
        "^" => Token22,
        "{" => Token23,
        "|+" => Token24a,  // "|" followed immediately by another "|"
        "|1" => Token24b,  // "|" followed by non-pipe
        "}" => Token25,
        "~" => Token26,
        SHL => Token27,
        SHR => Token28,
        LE => Token29,
        EQEQ => Token30,
        NE => Token31,
        GE => Token32,
        ANDAND => Token33,
        SHLEQ => Token35,
        SHREQ => Token36,
        MINUSEQ => Token37,
        ANDEQ => Token38,
        OREQ => Token39,
        PLUSEQ => Token40,
        STAREQ => Token41,
        SLASHEQ => Token42,
        CARETEQ => Token43,
        PERCENTEQ => Token44,
        DOTDOT => Token45,
        DOTDOTDOT => Token46,
        MOD_SEP => Token47,
        RARROW => Token48,
        LARROW => Token49,
        "->" => Token50,
        LIT_BYTE => Token51,
        LIT_CHAR => Token52,
        LIT_INTEGER => Token53,
        LIT_FLOAT => Token54,
        LIT_STR => Token55,
        LIT_STR_RAW => Token56,
        LIT_BYTE_STR => Token57,
        LIT_BYTE_STR_RAW => Token58,
        IDENT => Token59,
        UNDERSCORE => Token60,
        LIFETIME => Token61,
        SELF => Token62,
        STATIC => Token63,
        AS => Token64,
        "break" => Token65,
        CRATE => Token66,
        ELSE => Token67,
        ENUM => Token68,
        EXTERN => Token69,
        FALSE => Token70,
        FN => Token71,
        FOR => Token72,
        IF => Token73,
        IMPL => Token74,
        IN => Token75,
        LET => Token76,
        LOOP => Token77,
        MATCH => Token78,
        MOD => Token79,
        MOVE => Token80,
        MUT => Token81,
        PRIV => Token82,
        PUB => Token83,
        REF => Token84,
        "return" => Token85,
        STRUCT => Token86,
        TRUE => Token87,
        TRAIT => Token88,
        TYPE => Token89,
        UNSAFE => Token90,
        USE => Token91,
        WHILE => Token92,
        "continue" => Token93,
        BOX => Token95,
        CONST => Token96,
        WHERE => Token97,
        TYPEOF => Token98,
        INNER_DOC_COMMENT => Token99,
        OUTER_DOC_COMMENT => Token100,
        SHEBANG => Token101,
        SHEBANG_LINE => Token102,
        STATIC_LIFETIME => Token103,
    }
}
